# Тестовое задание 3
## Сборка контейнера
Сборка Docker-образа и запуск соответствующего контейнера:  
```docker buildx build -t fmba_2 -f docker_python_task.Dockerfile .```  
#моя папка
#``` docker run -it -v C:\Users\Eva\Desktop\стажировки\FMBA\ref:/ref/GRCh38.d1.vd1_mainChr/sepChrs/ fmba_2 ```
папка для ответа  
```docker run -it -v /mnt/data/ref/GRCh38.d1.vd1_mainChr/sepChrs/:/ref/GRCh38.d1.vd1_mainChr/sepChrs/ fmba_2```  

## Переформатирование исходного файла
Исходный файл (```FP_SNPs.txt```) имел формат:  
```rs#<TAB>chromosome<TAB>GB37_position<TAB>GB38_position<TAB>allele1<TAB>allele2```  
Так что сначала заменим названия колонок на целевые:  
```sed -i -e '1s/chromosome/#CHROM/' -e '1s/GB38_position/POS/' -e '1s/rs#/ID/' FP_SNPs.txt```  
Мы не заинтересованы в GB37_position, возьмем данные для более нового генома.  
Дальше, просто для удобства, поменяем колонки местами:  
```awk '{print $2, $4, $1, $5, $6}' FP_SNPs.txt >> FP_SNPs_10k_GB38_twoAllelsFormat.tsv```  
А также сделаем разделитель -- tab:  
```tr ' ' \\t < FP_SNPs_10k_GB38_twoAllelsFormat.tsv > temp.txt && mv temp.txt FP_SNPs_10k_GB38_twoAllelsFormat.tsv```  
Так, теперь мы имеем файл (```FP_SNPs_10k_GB38_twoAllelsFormat.tsv```) вида:  
```#CHROM<TAB>POS<TAB>ID<TAB>allele1<TAB>allele2```  
С ним мы и будем далее работать.  

## Деление общего файла с геномом на файлы с хромосомами
При помощи faSplit я разделила общий Fasta файл с геномом на файлы с хромосомами: chr*.fa. Так как копирование таких больших файлов в контейнер приводит к ошибке работы Docker (Docker is stuck on image exporting), файлы с хромосомами будут переданы в контейнер через папку, делимую контейнером и компьютером-хостом (определялись при запуске: ```/mnt/data/ref/GRCh38.d1.vd1_mainChr/sepChrs/:/ref/GRCh38.d1.vd1_mainChr/sepChrs/```)

## Запуск и работа скрипта
После создания контейнера на основе образа (получаемого при помощи docker_python_task.Dockerfile) можно обрабатывать файлы при помощи python_script.py. Он принимает на вход аргументы ```--input``` (обязательный), где необходимо задать путь до обрабатываемого файла (в нашем случае FP_SNPs_10k_GB38_twoAllelsFormat.tsv), а также ```--output``` (необязательный), где можно задать название получаемого файла. Пример запуска:  
```python3 python_script.py --input FP_SNPs_10k_GB38_twoAllelsFormat.tsv --output FP_SNPs_10k_GB38_REF_ALT_format.tsv```  
Сначала скрипт проверяет форматирование подаваемого файла: формат первой строки, разделитель, наличие ключевых колонок. Так как в техническом задании есть пункт "скрипт должен работать вне зависимости от формата конца строк входного файла" (где я приняла условность, что конец строк может содержать различный мусор, включая случайное количество разделителя=tab, но сам "мусор" отделен от прочей таблицы также разделителем=tab), то в скрипте также присутствует блок для решения этой задачи. Работает он следующим образом: скрипт считывает первую строчку файла, разделяет её по сепаратору, убирает технический символ переноса строки (\n) и пробелы. Далее в словах в первой строке происходит поиск названий ключевых колонок ('#CHROM', 'POS', 'ID', 'allele1', 'allele2'). Если колонки есть - остается их выделить, что оказывается нетривиальной задачей из-за потенциального "мусора" в файле. Поэтому скрипт находит индексы ключевых колонок (+1, т.к. индексация с нуля), запускает изнутри awk команду выделения нужных столбцов по номерам и записывает целевую таблицу во временный файл (temp.txt). Здесь, если глубже разобраться в том, как работает subprocess.run() можно попробовать оптимизировать этот этап и не копировать потенциально большую таблицу в temp.txt.  
Далее, если все было в порядке на проверках, файл подгружается в память.  

Я хотела решить задание самостоятельно и творчески, без использования сторонних биоинформатических библиотек для того, чтобы попробовать себя в оптимизации памяти и улучшении алгоритма. Поэтому далее алгоритм работает без использования pysam и работает следующим образом: сначала в файле проверяется первая строчка
для каждой соматической хромосомы O(22) построчно перебирается таблица O(n), которая подавалась на вход (snp) и выставляются референсные значения для каждой позиции SNP. Выбор референсного значения происходит каждый раз за O(1). Итоговый алгоритм работает за O(22 \* n), где 22 - константа. В результате, алгоритм работает за O(n), хотя скорость его работы зависит от размера таблицы. Далее происходит сравнение нуклеотидов в столбцах allele1 и allele2 с референсными нуклеотидами. Это происходит уже оптимальным путем - при помощи применения написанной мною функции comparison() на датасет с использованием apply(). Таблица, получающаяся в результате, но содержащая только ключевые столбцы, записывается в файл, которому было задано название или в файл output.tsv, если название не было задано. Удаляется временный файл temp.txt. 

## Пометка относительно pysam 
С точки зрения кода применение pysam.Fastafile было бы похоже, так как с помощью этой функции я бы могла загрузить нуклеотидные последовательности хромосом. Как я понимаю по завершении данного задания, pysam.Fastafile советовался благодаря возможности использования индексированного генома, что помогло бы быстро получать референсные последовательности. Я не нашла информации о том, как именно это реализовано, несмотря на распространенность знания о том, что индексация важна и нужна для облегчения поиска в больших нуклеотидных последовательностях, но могу предполагать, что так как python - высокоуровневый язык, использование pysam позволило бы сделать алгоритм менее "тяжелым". 

## Относительно технических требований
1. Скрипт принимает на вход 2 аргумента: обязательный --input и опциональный --output  
2. Скрипт включает проверку на наличие файла и его формат (на основе первой строки)  
3. Скрипт расставляет временные метки на самых времязатратных стадиях  
4. Скрипт содержит блок, позволяющий использовать файлы вне зависимости от конца строк входного файла путем ...  
5. Проверки и обработки первой строки входного файла  
6. Скрипт дает возможность вызвать его описание при помощи ```python3 python_script.py --help``` или ```python3 python_script.py -h``` 






